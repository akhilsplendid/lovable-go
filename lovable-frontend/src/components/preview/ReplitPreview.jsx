import React, { useState, useEffect, useCallback, useRef } from 'react'
import { motion } from 'framer-motion'
import { RefreshCw, ExternalLink, AlertCircle, Globe } from 'lucide-react'
import { PreviewFrame } from './PreviewFrame'
import { PreviewLoader } from './PreviewLoader'
import { PreviewControls } from './PreviewControls'
import Button from '../ui/Button'
import { useUIStore } from '../../store/uiStore'
import toast from 'react-hot-toast'

/**
 * ReplitPreview Component
 * Integrates with Replit API to provide sandboxed website preview
 */
export const ReplitPreview = ({ 
  project, 
  htmlCode = '', 
  cssCode = '', 
  jsCode = '',
  onCodeUpdate,
  className = ''
}) => {
  const { preview: previewSettings } = useUIStore()
  const [replState, setReplState] = useState({
    replId: null,
    previewUrl: null,
    status: 'idle', // idle, creating, running, error
    error: null,
    isPublic: false
  })
  
  const [isLoading, setIsLoading] = useState(false)
  const [lastCodeHash, setLastCodeHash] = useState('')
  const replCreationTimeoutRef = useRef(null)
  const previewUpdateTimeoutRef = useRef(null)

  // Create code hash for change detection
  const createCodeHash = useCallback((html, css, js) => {
    return btoa(html + css + js).slice(0, 16)
  }, [])

  /**
   * Create a new Replit instance
   */
  const createRepl = useCallback(async () => {
    if (!htmlCode.trim()) {
      setReplState(prev => ({
        ...prev,
        status: 'error',
        error: 'No HTML code to preview'
      }))
      return
    }

    setIsLoading(true)
    setReplState(prev => ({ ...prev, status: 'creating', error: null }))

    try {
      // For demo purposes, we'll simulate Replit API calls
      // In production, you'd use the actual Replit API
      const response = await simulateReplitAPI({
        title: project?.name || 'Lovable Website',
        description: project?.description || 'Generated by Lovable AI',
        files: {
          'index.html': htmlCode,
          'style.css': cssCode || '',
          'script.js': jsCode || ''
        }
      })

      setReplState({
        replId: response.replId,
        previewUrl: response.previewUrl,
        status: 'running',
        error: null,
        isPublic: response.isPublic
      })

      setLastCodeHash(createCodeHash(htmlCode, cssCode, jsCode))
      toast.success('Preview created successfully!')

    } catch (error) {
      console.error('Failed to create Replit:', error)
      setReplState(prev => ({
        ...prev,
        status: 'error',
        error: error.message || 'Failed to create preview'
      }))
      toast.error('Failed to create preview')
    } finally {
      setIsLoading(false)
    }
  }, [htmlCode, cssCode, jsCode, project, createCodeHash])

  /**
   * Update existing Replit with new code
   */
  const updateRepl = useCallback(async () => {
    if (!replState.replId || !htmlCode.trim()) return

    const newCodeHash = createCodeHash(htmlCode, cssCode, jsCode)
    if (newCodeHash === lastCodeHash) return

    setIsLoading(true)

    try {
      await simulateReplitUpdate(replState.replId, {
        'index.html': htmlCode,
        'style.css': cssCode || '',
        'script.js': jsCode || ''
      })

      setLastCodeHash(newCodeHash)
      
      // Force iframe refresh
      const iframe = document.querySelector('#preview-frame')
      if (iframe) {
        iframe.src = iframe.src
      }

    } catch (error) {
      console.error('Failed to update Replit:', error)
      toast.error('Failed to update preview')
    } finally {
      setIsLoading(false)
    }
  }, [replState.replId, htmlCode, cssCode, jsCode, lastCodeHash, createCodeHash])

  /**
   * Refresh the preview
   */
  const refreshPreview = useCallback(() => {
    if (replState.previewUrl) {
      updateRepl()
    } else {
      createRepl()
    }
  }, [replState.previewUrl, updateRepl, createRepl])

  /**
   * Open preview in new tab
   */
  const openInNewTab = useCallback(() => {
    if (replState.previewUrl) {
      window.open(replState.previewUrl, '_blank', 'noopener,noreferrer')
    }
  }, [replState.previewUrl])

  /**
   * Make preview public/private
   */
  const togglePublic = useCallback(async () => {
    if (!replState.replId) return

    try {
      setIsLoading(true)
      const response = await simulateTogglePublic(replState.replId, !replState.isPublic)
      
      setReplState(prev => ({
        ...prev,
        isPublic: response.isPublic
      }))

      toast.success(`Preview is now ${response.isPublic ? 'public' : 'private'}`)
    } catch (error) {
      toast.error('Failed to update privacy settings')
    } finally {
      setIsLoading(false)
    }
  }, [replState.replId, replState.isPublic])

  // Auto-create repl when code is first available
  useEffect(() => {
    if (htmlCode.trim() && !replState.replId && replState.status === 'idle') {
      replCreationTimeoutRef.current = setTimeout(createRepl, 1000)
    }

    return () => {
      if (replCreationTimeoutRef.current) {
        clearTimeout(replCreationTimeoutRef.current)
      }
    }
  }, [htmlCode, replState.replId, replState.status, createRepl])

  // Auto-update repl when code changes
  useEffect(() => {
    if (replState.replId && replState.status === 'running') {
      // Clear previous timeout
      if (previewUpdateTimeoutRef.current) {
        clearTimeout(previewUpdateTimeoutRef.current)
      }

      // Debounce updates
      previewUpdateTimeoutRef.current = setTimeout(updateRepl, 2000)
    }

    return () => {
      if (previewUpdateTimeoutRef.current) {
        clearTimeout(previewUpdateTimeoutRef.current)
      }
    }
  }, [htmlCode, cssCode, jsCode, replState.replId, replState.status, updateRepl])

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (replCreationTimeoutRef.current) {
        clearTimeout(replCreationTimeoutRef.current)
      }
      if (previewUpdateTimeoutRef.current) {
        clearTimeout(previewUpdateTimeoutRef.current)
      }
    }
  }, [])

  const renderContent = () => {
    if (replState.status === 'error') {
      return (
        <div className="flex flex-col items-center justify-center h-full p-8 text-center">
          <AlertCircle className="w-16 h-16 text-error-500 mb-4" />
          <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-2">
            Preview Error
          </h3>
          <p className="text-gray-600 dark:text-gray-400 mb-6 max-w-md">
            {replState.error}
          </p>
          <Button onClick={createRepl} variant="primary">
            Try Again
          </Button>
        </div>
      )
    }

    if (replState.status === 'creating' || (isLoading && !replState.previewUrl)) {
      return <PreviewLoader message="Creating secure preview environment..." />
    }

    if (!htmlCode.trim()) {
      return (
        <div className="flex flex-col items-center justify-center h-full p-8 text-center">
          <Globe className="w-16 h-16 text-gray-400 mb-4" />
          <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-2">
            No Content Yet
          </h3>
          <p className="text-gray-600 dark:text-gray-400 max-w-md">
            Start a conversation with AI to generate your website, and it will appear here in real-time.
          </p>
        </div>
      )
    }

    if (replState.previewUrl) {
      return (
        <PreviewFrame
          src={replState.previewUrl}
          title={project?.name || 'Website Preview'}
          isLoading={isLoading}
          device={previewSettings.device}
          zoom={previewSettings.zoom}
        />
      )
    }

    return <PreviewLoader message="Initializing preview..." />
  }

  return (
    <motion.div 
      className={`preview-frame bg-white dark:bg-gray-800 h-full flex flex-col ${className}`}
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
    >
      {/* Preview Header */}
      <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center space-x-2">
          <h3 className="font-medium text-gray-900 dark:text-gray-100">
            Live Preview
          </h3>
          {replState.isPublic && (
            <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-success-100 text-success-800 dark:bg-success-800 dark:text-success-100">
              <Globe className="w-3 h-3 mr-1" />
              Public
            </span>
          )}
          {isLoading && (
            <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-warning-100 text-warning-800 dark:bg-warning-800 dark:text-warning-100">
              <RefreshCw className="w-3 h-3 mr-1 animate-spin" />
              Updating
            </span>
          )}
        </div>

        <div className="flex items-center space-x-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={refreshPreview}
            disabled={isLoading}
            leftIcon={RefreshCw}
            className={isLoading ? 'animate-spin' : ''}
          >
            Refresh
          </Button>
          
          {replState.previewUrl && (
            <>
              <Button
                variant="ghost"
                size="sm"
                onClick={openInNewTab}
                leftIcon={ExternalLink}
              >
                Open
              </Button>
              
              <Button
                variant="outline"
                size="sm"
                onClick={togglePublic}
                disabled={isLoading}
                leftIcon={Globe}
              >
                {replState.isPublic ? 'Make Private' : 'Make Public'}
              </Button>
            </>
          )}
        </div>
      </div>

      {/* Preview Controls */}
      {replState.previewUrl && (
        <PreviewControls 
          device={previewSettings.device}
          zoom={previewSettings.zoom}
          responsive={previewSettings.responsive}
          showGrid={previewSettings.showGrid}
        />
      )}

      {/* Preview Content */}
      <div className="flex-1 relative overflow-hidden">
        {renderContent()}
      </div>

      {/* Preview Footer */}
      <div className="flex items-center justify-between px-4 py-2 bg-gray-50 dark:bg-gray-700/50 text-xs text-gray-500 dark:text-gray-400 border-t border-gray-200 dark:border-gray-700">
        <span>
          {replState.status === 'running' && 'Secure sandboxed environment'}
          {replState.status === 'creating' && 'Setting up environment...'}
          {replState.status === 'error' && 'Preview unavailable'}
          {replState.status === 'idle' && 'Ready to preview'}
        </span>
        
        {replState.replId && (
          <span className="font-mono text-2xs">
            ID: {replState.replId.slice(0, 8)}...
          </span>
        )}
      </div>
    </motion.div>
  )
}

// Simulate Replit API calls (replace with actual API in production)
const simulateReplitAPI = async ({ title, description, files }) => {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 2000))
  
  const replId = `repl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  // Create blob URL for preview (in production, this would be Replit's URL)
  const htmlContent = files['index.html']
  const cssContent = files['style.css']
  const jsContent = files['script.js']
  
  const fullHtml = htmlContent.replace(
    '</head>',
    `${cssContent ? `<style>${cssContent}</style>` : ''}</head>`
  ).replace(
    '</body>',
    `${jsContent ? `<script>${jsContent}</script>` : ''}</body>`
  )
  
  const blob = new Blob([fullHtml], { type: 'text/html' })
  const previewUrl = URL.createObjectURL(blob)
  
  return {
    replId,
    previewUrl,
    isPublic: false
  }
}

const simulateReplitUpdate = async (replId, files) => {
  await new Promise(resolve => setTimeout(resolve, 1000))
  return { success: true }
}

const simulateTogglePublic = async (replId, isPublic) => {
  await new Promise(resolve => setTimeout(resolve, 500))
  return { isPublic }
}

export default ReplitPreview